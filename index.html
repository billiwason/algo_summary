<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Rows to Individual HTML Tables</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px; /* 각 테이블 간의 공백을 설정 */
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        .table-odd {
            background-color: #f2f2f2;
        }
        .table-even {
            background-color: #ffffff;
        }
    </style>
</head>
<body>

    <div id="table-container"></div>

    <script>
        // JSON 데이터
        const jsonData = [
            {
                "제목" : "E - Tree and Hamilton Path 2",
                "문제": "트리의 모든 노드를 한번씩 순회하였을때 최단 거리를 찾는 문제", 
                "해법": "전체 길의의 합 * 2 - (트리의 지름). \n트리의 지름구하는 방법은" + 
                "\n1) 임의의 노드를 Root 로 잡고 에서 제일 긴 노드 찾기." + 
                "\n2) 제일 긴 노드를 Root 를 젭고 해당 노드에서 제일 긴 거리를 찾으면 그것이 곧 트리의 지름이 된다", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_e", 
                "코드링크" : "https://atcoder.jp/contests/abc361/submissions/55343394",
                "대표이미지" : "abc361_f.png"
            },
            {
                "제목": "G - Go Territory",
                "문제": "검은돌의 좌표가 주어지고 만약 어떤 빈곳에 흰돌이 놓여있다면 잡힐 수 밖에 없는 영역의 개수를 구하는 문제", 
                "해법": "세로로 스위핑 하면서 각 줄별로 연속된 빈곳을 영역으로 구분함(L 과 R 의 구조체)" + 
                "\n2) 각줄별로 현재줄과 다음줄 을 비교하여 위아래로 겹치는 영역끼리 합친다(영역별로 ID 를 부여하여 union-find 로 합침)" + 
                "\n2) -1,-1 이 있는 지점의 ID 와 같지 않은 영역들의 크기의 합을 계산하면 답이된다.", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_g", 
                "코드링크" : "아직못품",
                "대표이미지" : "abc361_g.png"
            },
            {
                "제목": "경찰차",
                "문제": "2차원 공간에 경찰자가 이동하여 사건을 해결하는데 최소한한의 이동거리와 1,2 경찰자중 각각 어떤 경찰차를 선택해야 하는지 결정하는 문제", 
                "해법": "DP[i][j] 는 1 번, 2번 경찰자의 마지막 처리 위치이며, DP[max(i,j)+1][j] = DP[i][j] + 거리(i -> max(i,j)+1)" + 
                "\n2) 로 계산할 수 있다. 각 DP 값이 갱신될 때마다 어디서 이동했는지 기록한다.",
                "문제링크" : "https://www.acmicpc.net/problem/2618", 
                "코드링크" : "https://www.acmicpc.net/source/81325734",
                "대표이미지" : "bj_2618.png"
            },
            {
                "제목": "사전",
                "문제": "N개의 a 와 M 개의 z 의 조합으로 문자열을 만들때 K 번째 문자열은 무엇인가?", 
                "해법": "DP[i][j] 는 a의 갯수가 i 개이고 b의 개수가 j 일때 가능한 모든 문자열의 개수로 정의한다." + 
                "\n2) 만약 DP[i-1][j] 보다 K 가 더 크면 i+j 번째 문자열은 z 이다. 이런식의 크기비교로 순서대로 a,z 여부를 판단할 수 있다." +
                "\n2) 단 DP 테이블 값이 너무 커져서 오버플로우가 나면 비교에 문제가 생기기 때문에 K 의 범위보다 큰 값을 정의해서 해당 값이 넘어가지 않게 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1256", 
                "코드링크" : "https://www.acmicpc.net/source/81381697",
                "대표이미지" : "bj_1256.png"
            },
            {
                "제목": "로봇 조종하기",
                "문제": "2차원 공간을 좌,우, 하로 이동이 가능할때 (1,1) -> (R,C) 로 이동하면서 최대한 이득을 낼수 있는 값은 얼마인지 찾는 문제", 
                "해법": "DP[i][j] 는 1,1 에서 ij 로 왔을때 최대값을 의미함." + 
                "\n위에서 내려왔을때의 값, 왼쪽에서왔을때의 값, 그리고 오른쪽에서 왔을때의 값중 최대값을 선택하면 된다." +
                "\n위에서 왔을때의 값은 DP[i-1][j] 이며, 왼쪽에서, 또는 오른쪽에서 스윕하면서 L[j], R[J] 를 계산해 주어야한다" + 
                "\nDP[i][j] = max(L[j], R[J]) 로 도출할 수 있다. ",
                "문제링크" : "https://www.acmicpc.net/problem/2169", 
                "코드링크" : "https://www.acmicpc.net/source/81392028",
                "대표이미지" : "bj_2169.png"
            },
            {
                "제목": "우수 마을",
                "문제": "다음 조건을 만족하는 최대 값을 구해야함." +
                "\n 1) 부모자식은 동시 선택안됨." +
                "\n 2) 모든 노드는 선택된 노드와 최소 하나와 연결되어야함.", 
                "해법": "DP[0][idx] = idx 노드가 선택안되었을때 최대값, DP[1][idx] = idx 가 선택되었을때 최대값" +
                "\n 최대값을 구하려면 사실 2번조건은 고려하지 않아도 됨. 왜냐하면 인접한 3개의 노드가 동시에 선택안될 경우는 없기 때문.",
                "문제링크" : "https://www.acmicpc.net/problem/1949", 
                "코드링크" : "https://www.acmicpc.net/source/81643593",
                "대표이미지" : "bj_1949.png"
            },
            {
                "제목": "트리의 독립집합",
                "문제": "앞의 문제와 동일한데 선택된 노드 집합을 구해야 함.",
                "해법": "1번노드부터 DFS 로 추적해서 결과에 노드를 쌓아야 한다." +
                "\n1)만약 DP[1][i] > DP[0][i] 이면 현재 노드 선택" +
                "\n2)모든 자식노드들을 검사하여 만약 현재 노드가 선택되었을경우 자식노드들은 선택하지 않는다." +
                "\n3)모든 자식노드들을 검사하여 만약 현재 노드가 선택되지 않는경우 DP[1][next] > DP[0][next] 일경우 자식노드들을 선택한다",
                "문제링크" : "https://www.acmicpc.net/problem/2213", 
                "코드링크" : "https://www.acmicpc.net/source/81656137",
            },
            {
                "제목": "도로포장",
                "문제": "그래프의 최단 거리를 구해야 하는 문제이지만, 최대 K 개 까지 도로포장을 통해 길이를 0 으로 만들 수 있다.",
                "해법": "다익스트라를 응용하여 DIST[dest][포장한갯수] 로 확장하여야 한다." +
                "\n PQ 에 넣을 때 포장할 경우와 포장하지 않을 경우 2가지를 고려해야 함.",
                "문제링크" : "https://www.acmicpc.net/problem/1162", 
                "코드링크" : "https://www.acmicpc.net/source/81680485",
            },
            {
                "제목": "다이아몬드 광산",
                "문제": "맵에서 가장 큰 다이아 몬드를 찾는 문제",
                "문제이미지" : "bj_1028.png",
                "해법": "각점애서 좌하, 또는 우하로 이여지는 1의 개수가 몇개인지 DP 로 쌓은 후 부르트 포스로 최대 값을 구핼 수 있다." +
                "\n단 DP 테이블을 만들때에는 아래에서 위로 스윕해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1028", 
                "코드링크" : "https://www.acmicpc.net/source/81751083",
            },

            {
                "제목": "이항계수4",
                "문제": "N, R, P 가 주어졌을때 이항계수binaryCoeff(N,R) 을 P 로 mod 한 값을 찾는 문제",
                "해법": "뤼카의 정리를 이용하며 쉽게 계산할 수있다." +
                "\n뤼카의 정리 : N,R 을 P 진수로 표현할때 각자리수 별로 이항계수를 구하여 곱한 것과 통일하다.",
                "문제링크" : "https://www.acmicpc.net/problem/11402", 
                "코드링크" : "https://www.acmicpc.net/source/81760595",
                "대표이미지" : "bj_11402.png",
                "참고" : "그림의 괄호는 행렬이 아니라 이항계수를 의미함"
            },
            
        ];

        // 줄바꿈 문자를 <br> 태그로 변환하는 함수
        function nl2br(str) {
            return str.replace(/\n/g, '<br>');
        }

        // JSON 배열의 각 행을 개별 HTML 테이블로 변환하는 함수
        function jsonToIndividualTables(jsonArray) {
            const container = document.createElement('div');

            jsonArray.forEach((item, index) => {
                const table = document.createElement('table');

                // 테이블 헤더 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = Object.keys(item);
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // 테이블 바디 생성
                const tbody = document.createElement('tbody');
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    // 줄바꿈 문자를 <br> 태그로 변환하여 innerHTML에 할당

                    if (header === '문제링크' || header === '코드링크') {
                        const link = document.createElement('a');
                        link.href = `${item[header]}`;
                        if (item[header] == '아직못품')
                            link.textContent = '아직못품';
                        else
                            link.textContent = 'CLICK';
                        link.target = '_blank';
                        td.appendChild(link);
                    } else if(header == "대표이미지" || header == "문제이미지") {
                        const img = document.createElement('img');
                        img.src = item[header];
                        td.appendChild(img);
                    }
                    else {
                        td.innerHTML = nl2br(item[header].toString());
                    }
                    row.appendChild(td);
                });
                tbody.appendChild(row);
                table.appendChild(tbody);

                // 짝수 인덱스 테이블에 클래스 추가
                if (index % 2 === 0) {
                    table.classList.add('table-even');
                } else {
                    table.classList.add('table-odd');
                }

                container.appendChild(table);
            });

            return container;
        }

        // 개별 테이블을 페이지에 추가
        const tableContainer = document.getElementById('table-container');
        const tables = jsonToIndividualTables(jsonData);
        tableContainer.appendChild(tables);
    </script>

</body>
</html>
