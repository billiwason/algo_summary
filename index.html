<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Rows to Individual HTML Tables</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px; /* 각 테이블 간의 공백을 설정 */
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        .table-odd {
            background-color: #f2f2f2;
        }
        .table-even {
            background-color: #ffffff;
        }
    </style>
</head>
<body>

    <div id="table-container"></div>

    <script>
        // JSON 데이터
        const jsonData = [
            {
                "제목" : "E - Tree and Hamilton Path 2",
                "문제": "트리의 모든 노드를 한번씩 순회하였을때 최단 거리를 찾는 문제", 
                "해법": "전체 길의의 합 * 2 - (트리의 지름). \n트리의 지름구하는 방법은" + 
                "\n1) 임의의 노드를 Root 로 잡고 에서 제일 긴 노드 찾기." + 
                "\n2) 제일 긴 노드를 Root 를 젭고 해당 노드에서 제일 긴 거리를 찾으면 그것이 곧 트리의 지름이 된다", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_e", 
                "코드링크" : "https://atcoder.jp/contests/abc361/submissions/55343394",
                "대표이미지" : "abc361_f.png"
            },
            {
                "제목": "G - Go Territory",
                "문제": "검은돌의 좌표가 주어지고 만약 어떤 빈곳에 흰돌이 놓여있다면 잡힐 수 밖에 없는 영역의 개수를 구하는 문제", 
                "해법": "세로로 스위핑 하면서 각 줄별로 연속된 빈곳을 영역으로 구분함(L 과 R 의 구조체)" + 
                "\n2) 각줄별로 현재줄과 다음줄 을 비교하여 위아래로 겹치는 영역끼리 합친다(영역별로 ID 를 부여하여 union-find 로 합침)" + 
                "\n2) -1,-1 이 있는 지점의 ID 와 같지 않은 영역들의 크기의 합을 계산하면 답이된다.", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_g", 
                "코드링크" : "아직못품",
                "대표이미지" : "abc361_g.png"
            },
            {
                "제목": "경찰차",
                "문제": "2차원 공간에 경찰자가 이동하여 사건을 해결하는데 최소한한의 이동거리와 1,2 경찰자중 각각 어떤 경찰차를 선택해야 하는지 결정하는 문제", 
                "해법": "DP[i][j] 는 1 번, 2번 경찰자의 마지막 처리 위치이며, DP[max(i,j)+1][j] = DP[i][j] + 거리(i -> max(i,j)+1)" + 
                "\n2) 로 계산할 수 있다. 각 DP 값이 갱신될 때마다 어디서 이동했는지 기록한다.",
                "문제링크" : "https://www.acmicpc.net/problem/2618", 
                "코드링크" : "https://www.acmicpc.net/source/81325734",
                "대표이미지" : "bj_2618.png"
            },
            {
                "제목": "사전",
                "문제": "N개의 a 와 M 개의 z 의 조합으로 문자열을 만들때 K 번째 문자열은 무엇인가?", 
                "해법": "DP[i][j] 는 a의 갯수가 i 개이고 b의 개수가 j 일때 가능한 모든 문자열의 개수로 정의한다." + 
                "\n2) 만약 DP[i-1][j] 보다 K 가 더 크면 i+j 번째 문자열은 z 이다. 이런식의 크기비교로 순서대로 a,z 여부를 판단할 수 있다." +
                "\n2) 단 DP 테이블 값이 너무 커져서 오버플로우가 나면 비교에 문제가 생기기 때문에 K 의 범위보다 큰 값을 정의해서 해당 값이 넘어가지 않게 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1256", 
                "코드링크" : "https://www.acmicpc.net/source/81381697",
                "대표이미지" : "bj_1256.png"
            },
            {
                "제목": "로봇 조종하기",
                "문제": "2차원 공간을 좌,우, 하로 이동이 가능할때 (1,1) -> (R,C) 로 이동하면서 최대한 이득을 낼수 있는 값은 얼마인지 찾는 문제", 
                "해법": "DP[i][j] 는 1,1 에서 ij 로 왔을때 최대값을 의미함." + 
                "\n위에서 내려왔을때의 값, 왼쪽에서왔을때의 값, 그리고 오른쪽에서 왔을때의 값중 최대값을 선택하면 된다." +
                "\n위에서 왔을때의 값은 DP[i-1][j] 이며, 왼쪽에서, 또는 오른쪽에서 스윕하면서 L[j], R[J] 를 계산해 주어야한다" + 
                "\nDP[i][j] = max(L[j], R[J]) 로 도출할 수 있다. ",
                "문제링크" : "https://www.acmicpc.net/problem/2169", 
                "코드링크" : "https://www.acmicpc.net/source/81392028",
                "대표이미지" : "bj_2169.png"
            },
            {
                "제목": "우수 마을",
                "문제": "다음 조건을 만족하는 최대 값을 구해야함." +
                "\n 1) 부모자식은 동시 선택안됨." +
                "\n 2) 모든 노드는 선택된 노드와 최소 하나와 연결되어야함.", 
                "해법": "DP[0][idx] = idx 노드가 선택안되었을때 최대값, DP[1][idx] = idx 가 선택되었을때 최대값" +
                "\n 최대값을 구하려면 사실 2번조건은 고려하지 않아도 됨. 왜냐하면 인접한 3개의 노드가 동시에 선택안될 경우는 없기 때문.",
                "문제링크" : "https://www.acmicpc.net/problem/1949", 
                "코드링크" : "https://www.acmicpc.net/source/81643593",
                "대표이미지" : "bj_1949.png"
            },
            {
                "제목": "트리의 독립집합",
                "문제": "앞의 문제와 동일한데 선택된 노드 집합을 구해야 함.",
                "해법": "1번노드부터 DFS 로 추적해서 결과에 노드를 쌓아야 한다." +
                "\n1)만약 DP[1][i] > DP[0][i] 이면 현재 노드 선택" +
                "\n2)모든 자식노드들을 검사하여 만약 현재 노드가 선택되었을경우 자식노드들은 선택하지 않는다." +
                "\n3)모든 자식노드들을 검사하여 만약 현재 노드가 선택되지 않는경우 DP[1][next] > DP[0][next] 일경우 자식노드들을 선택한다",
                "문제링크" : "https://www.acmicpc.net/problem/2213", 
                "코드링크" : "https://www.acmicpc.net/source/81656137",
            },
            {
                "제목": "도로포장",
                "문제": "그래프의 최단 거리를 구해야 하는 문제이지만, 최대 K 개 까지 도로포장을 통해 길이를 0 으로 만들 수 있다.",
                "해법": "다익스트라를 응용하여 DIST[dest][포장한갯수] 로 확장하여야 한다." +
                "\n PQ 에 넣을 때 포장할 경우와 포장하지 않을 경우 2가지를 고려해야 함.",
                "문제링크" : "https://www.acmicpc.net/problem/1162", 
                "코드링크" : "https://www.acmicpc.net/source/81680485",
            },
            {
                "제목": "다이아몬드 광산",
                "문제": "맵에서 가장 큰 다이아 몬드를 찾는 문제",
                "문제이미지" : "bj_1028.png",
                "해법": "각점애서 좌하, 또는 우하로 이여지는 1의 개수가 몇개인지 DP 로 쌓은 후 부르트 포스로 최대 값을 구핼 수 있다." +
                "\n단 DP 테이블을 만들때에는 아래에서 위로 스윕해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1028", 
                "코드링크" : "https://www.acmicpc.net/source/81751083",
            },

            {
                "제목": "이항계수4",
                "문제": "N, R, P 가 주어졌을때 이항계수binaryCoeff(N,R) 을 P 로 mod 한 값을 찾는 문제",
                "해법": "뤼카의 정리를 이용하며 쉽게 계산할 수있다." +
                "\n뤼카의 정리 : N,R 을 P 진수로 표현할때 각자리수 별로 이항계수를 구하여 곱한 것과 통일하다.",
                "문제링크" : "https://www.acmicpc.net/problem/11402", 
                "코드링크" : "https://www.acmicpc.net/source/81760595",
                "대표이미지" : "bj_11402.png",
                "참고" : "그림의 괄호는 행렬이 아니라 이항계수를 의미함"
            },
            {
                "분류" : "DP",
                "제목": "전구",
                "문제": "나열된 전구들의 색깔을 동일하게 맞출 수 있는 최소 방법 을 구하는 문제",
                "해법": "DP[S][E] = Min(DP[S][K] + DP[K+1][E]) + A  로 구할 수 있다. A 는 bulb[S] == bulb[K+1] 일 경우 0 그외는 1" +
                "\n비재귀로 풀려면 S 는 역순으로 순회해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/11402", 
                "코드링크" : "https://www.acmicpc.net/source/81760595",
                "대표이미지" : "bj_2449.png",
            },
            {
                "분류" : "lazy segtree",
                "제목": "구간 합 구하기 2",
                "문제": "구간 업데이트 및 Query 가 필요하므로 Lazy Segtree 가 적용되어야 한다.",
                "해법": "Atcoder 의 Lazy Segtree 를 도입하여 업데이트및 Query 를 수행하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/10999", 
                "코드링크" : "https://www.acmicpc.net/submit/10999/78148216",
                "대표이미지" : "bj_10999.png",
            },
            {
                "분류" : "Fanwick tree\n(폔윅트리)",
                "제목": "구간 합 구하기 4",
                "문제": "원소 업데이트및 구간 합 쿼리를 해야함.",
                "해법": "펜윅트리를 이용하여 구간쿠리를 수행함. FW Tree 클래스 성질은 아래와 같다." +
                "\n index 0 은 미사용. 1부터~ N 까지 쿼리함." +
                "\n 쿼리시  S, E 둘다 포함됨.",
                "문제링크" : "https://www.acmicpc.net/problem/11659", 
                "코드링크" : "https://www.acmicpc.net/source/81789965",
            },
            {
                "분류" : "Fanwick tree\n(폔윅트리)",
                "제목": "중앙값",
                "문제": "N개의 수열에서 K 개만큼 시작부터 스윕해가면서 중앙값들의 합을 구하는 문제",
                "해법": "펜윅트리 에 대상 부분 수열을 넣었다 뻬기를 반복하면서 이진 탐색을 통해 중앙 번째의 값을 구할 수 있다." +
                "\n 입력값 제한이 65535 이므로 Tree 의 배열은 각 숫자들의 개수를 의미한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1572", 
                "코드링크" : "https://www.acmicpc.net/source/81797697",
            },
            {
                "분류" : "DP",
                "제목": "전시장",
                "문제": "그림을 일렬로 전시하였을때 높이 차이가 S 이상 유지되는 그림만 가격이 매겨질때 최대 가격을 벌 수있는 경우가 얼마인지 찾는문제",
                "해법": "그림개수와 높이 제약이 너무 큰값이므로 DP 는 무조건 1차원 DP Table 이어야 한다." +
                "\n DP[i] 는 i 번째 그림이 판매가격에 포함되는 최대 가격으로 정의한다. 1부터 i-1 번째 까지 높이차가 S 이상 차이나는 최대 가격 + 현재 가격으로 도출할 수 있다." +
                "\n i+1 번째 그림 탐색시작은 i 번째 까지 탐색한 시점부터 탐색하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/2515", 
                "코드링크" : "https://www.acmicpc.net/source/81840975",
                "대표이미지" : "bj_2515.png",
            },
            {
                "분류" : "DP",
                "제목": "평범한 배낭",
                "문제": "표준적인 knapsack DP 문제",
                "해법": "DP[i][k] = i 번째 물건까지 사용한 용량이 K 일때 최대 만족도" +
                "\n DP[i][k] = max(DP[i-1][k] , DP[i-1][k-w[i]] + s[i] )" +
                "\n w[i] : i번째물건의 무게, s[i] : i 번째 물건의 만족도",
                "문제링크" : "https://www.acmicpc.net/problem/12865", 
                "코드링크" : "https://www.acmicpc.net/source/81851284",
            },
            {
                "분류" : "DP",
                "제목": "평범한 배낭",
                "문제": "knapsack DP 문제인데 각 물건은 N 개 까지 선택할 수 있음.",
                "해법": "각각의 물건의 크기를 2^n 의 집합으로 쪼갠 후(쪼갠 값들의 합은 물건의 개수와 같아야 한다.) " +
                "\n knapsack DP 로 풀이할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/12920", 
                "코드링크" : "https://www.acmicpc.net/source/81849885",
                "대표이미지" : "bj_12920.png",
            },
            {
                "분류" : "meet in the middle",
                "제목": "Parcel",
                "문제": "정수 List 에서 임의의 4개를 선택하여 합할시 Target 값이 존재하는지 판단하는 문제",
                "해법": "브루트포스로 풀면 N^3 이므로 시간내에 풀 수 없다. " +
                "\n 주어진 원소들 중에서 모든 원소쌍을 미리 Caching 해 놓은후 똑같이 순회하면서 인덱스 중복이 안되면서 각쌍의 합이 원하는 값인지 비교하면된다." +
                "\n 어떤 값을 만드는 원소 쌍은 단 하나만 Caching 해도 된다는 것이 핵심.",
                "문제링크" : "https://www.acmicpc.net/problem/16287", 
                "코드링크" : "https://www.acmicpc.net/source/81866971"
            },

            {
                "분류" : "포함배제의 원리",
                "제목": "N포커",
                "문제": "52장중 N 개의 카드를 뽑아서 포커가 나올 수 있는 경우의 수를 구하기",
                "해법": "52개의 경우중 N 장을 뽑는 모든 경우의 수를 DP 를 통해 미리 계산해 놓는다." +
                "\n 4장의 카드를 뽑고 나머지 카드 중 num-4 장의 카드를 뽑는 경우의 수를 생각해 볼 수 있다." +
                "\n 하지만 뽑아야 하는 카드가 8장일경우 포커가 2쌍 선택되는 경우가 중복 될 수 있다." +
                "\n 따라서 포함 배제의 원리를 이용하여 1개 이상의 포커를 뽑는 경우의 수를 도출해야 한다. " +
                "\n 예를들어 13의 카드를 뽑을때 1쌍 이상의 포커를 뽑는 경우의 수는 아래와 같다." +
                "\n ans = COMB[13][1] * COMB[52-4][13-4] - COMB[13][2] * COMB[52-8][13-8] + COMB[13][3] * COMB[52-12][13-12] " +
                "\n k쌍 이상을 뽑는 경우의 수 = 1한쌍뽑는 경우 - 2쌍뽑는 경우 + 3쌍뽑는 경우 - 4쌍뽑는 경우 .... ",
                "문제링크" : "https://www.acmicpc.net/problem/16565", 
                "코드링크" : "https://www.acmicpc.net/source/81943011"
            },
            {
                "분류" : "dijkstra DP",
                "제목": "KCM Trable",
                "문제": "Node 1 에서 N 까지 가는데 주어진 한계비용을 초과하지 않는 한도 내에서 가장 빨리 도착하는 방법을 찾기",
                "해법": "비용 기준으로 2차원 Dijkstra DP 로 구현하는데 시간 초과를 해법하기 위해 몇가지 기술을 적용해야 한다." +
                "\n 1) DEST[k][cost] 값이 업데이트 되면 DEST[k][const + 1] ~ DEST[k][const + Limit] 까지의 값도 같이 업데이트해주어야 한다." +
                "\n 2) K 가 최종 도착지라면 loop 를 빠져나온다. 우선순위가 소요시간 기준이기 때문이다." +
                "\n 3) Edge 를 비용기준으로 정렬해 주어야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/10217", 
                "코드링크" : "https://www.acmicpc.net/source/81962027"
            },
            {
                "분류" : "DP + Greedy",
                "제목": "커플 만들기",
                "문제": "남자 N명 여자 M 명을 최대한 매칭하였을때 성격차이가 최소화 되도록 매칭 하는 경우를 찾기",
                "해법": "남자,여자를 각각 성격순으로 정렬한다." +
                "\n DP[i][j] 는 i 번째 남자와 j 번째 여자를 매칭하였을 때 최소 성격차로 정의" +
                "\n DP[i][j] = min(DP[i-1][0] .. DP[i-1][j-1]) + diff(N[i] , M[j]) 로 계산하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/1727", 
                "코드링크" : "https://www.acmicpc.net/source/82069160"
            },
            {
                "분류" : "누적합,비트마스크",
                "제목": "XOR 합 3",
                "문제": "수열의 모든 부분수열의 XOR 합을 구하기",
                "해법": "S[i] 를 A[0] ... A[i] 까지의 XOR 이라고 정의하면 모든 S[i] 를 미리 계산해 놓는다." +
                "\n 모든 I 를 순회하면서 각비트별로 1 인경우 홀수 Count 감소 후 홀수 짝수 swap" +
                "\n 각 비트별로 0 인경우 짝수 count 를 감소시키면서 홀수 카운트 만큼 결과에 반복 더해준다.",
                "문제링크" : "https://www.acmicpc.net/problem/13710", 
                "코드링크" : "https://www.acmicpc.net/source/82075352",
                "대표이미지" : "bj_13710.png",
            },
            {
                "분류" : "DP",
                "제목": "방법을 출력하지 않는 숫자 맞추기",
                "문제": "N 개의 나사가 쌓여있고 왼쪽으로 돌리면 아래의 모든 나사들이 같이돌아가고 오른쪽으로만 돌리면 현재 나사만 돌아간다." +
                "\n 시작숫자에서 끝숫자 까지 이르는데 나사를 돌리는 최소 횟수를 구해야 함.",
                "문제이미지" : "bj_13392.png",
                "해법": "i 번째 나사기준으로 왼쪽으로 몇번 돌았을때 N번째 까지 모두 맞추는데 얼마나 걸리는지 계산하는 table 을정의한다" +
                "\n DP[i][왼쪽 돌아간 횟수] = min(DP[i+1][i번째를 맞추기 위해 돌려야할 왼쪽회전수] + 회전수를 달성하기 위한 추가 왼쪽 회전수, " +
                "\n DP[i+1][왼쪽 돌아간횟수] + 회전수를 달성하기 위한 추가 오른쪽 회전수)", 
                "문제링크" : "https://www.acmicpc.net/problem/13392", 
                "코드링크" : "https://www.acmicpc.net/source/82233795",
                "대표이미지" : "bj_13392_2.png",
            },
            {
                "분류" : "DP",
                "제목": "숫자 맞추기",
                "문제": "앞의문제 BJ-13392 와 동일하지만 어떤 나사를 어느쪽으로 움직였는지 경로를 출력해 주어야함",
                "해법": "trace table 을 만들어 TRACE[i][j] = pair(next 회전수, 현재나사를 맞추기위한 회전수) 로 정의하여 TRACE[0][0] 부터 추적하면 된다",
                "문제링크" : "https://www.acmicpc.net/problem/2494", 
                "코드링크" : "https://www.acmicpc.net/source/82234443",
            },
            {
                "분류" : "DP",
                "제목": "타일 채우기",
                "문제": "3*N 크기의 벽을 2X1 또는 1X2 타일로 채우는 경우의 수 구하기",
                "해법": "DP[i][000~111] = i 변째 까지 벽돌을 채우는데 제일 오른쪽 벽돌이 부분적으로 채워졌을 때 채울 수 있는 경우의 수로 정의하여 테이블을 채우면 된다." +
                "\n 단 최초 가상의 벽을 만들고 DP[0][7] 만 1로 채운다. 왜냐하면 첫번째 줄은 이전 줄을 침범하여 벽돌을 쌓을 수 없기 때문이다",
                "문제링크" : "https://www.acmicpc.net/problem/2133", 
                "코드링크" : "https://www.acmicpc.net/source/82260641",
                "대표이미지" : "bj_2133.png",
            },
            {
                "분류" : "DP",
                "제목": "동전문제",
                "문제": "특정금액을 채울수 있는 동전의 최소 갯수 구하기",
                "해법": "금액이 최대 10^17 이므로 전체 금액을 DP table 로 채울 수는 없다. 다만 동전에 규칙이 있기 때문에 규칙을 파악하는 것이 핵심." +
                "\n 매 백단위 마다 1, 10,25 짜리 동전으로 가정할 수 있기 때문에 0~99 까지 만들수 있는 최소 동전을 만들고 2자리 단위로 끊어서 더하면 됨.",
                "문제링크" : "https://www.acmicpc.net/problem/1398", 
                "코드링크" : "https://www.acmicpc.net/source/82505436",
                "대표이미지" : "bj_1398.png",
            },
            {
                "분류" : "DP",
                "제목": "교차하지 않는 원의 현들의 최대 집합",
                "문제": "원위의 N 개의 현들중 교차하지 않는 현들의 최대 개수를 구하는 문제",
                "문제이미지" :  "bj_2673.png",
                "해법": "원을 직선으로 펼쳐도 동일한 계산 결과가 나온다는 것이 핵심. DP[i][j] = i~j 까지를 가지고 만들수 있는 최대 현의 개수로 정의" +
                "\n DP[i][j] = max(DP[i][k] + DP[k][j]) , k 는 i~j",
                "문제링크" : "https://www.acmicpc.net/problem/2673", 
                "코드링크" : "https://www.acmicpc.net/source/82596905",
                "대표이미지" : "bj_2673_1.png",
            },
            {
                "분류" : "DP",
                "제목": "기지국",
                "문제": "좌표위에 모든 건물을 포함하는 최소 기지국의 길이를 구하는 문제.기지국의 크기는 항상 정사각형이다",
                "문제이미지" :  "bj_2300.png",
                "해법": "DP[i] 는 i 번째까지의 최소 길이로 정의 하면" +
                "\n DP[i] = min(DP[k] + K+1 ~ i 까지 하나로 묵을 수있는 최소 길이) 단 K 는 0~i 의 범위임." +
                "\n N 의 제약이 최대 10000 일경우 로직이 복잡하지 않으면 N^2 알고리즘이 시간내에 돌 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/2300", 
                "코드링크" : "https://www.acmicpc.net/source/82604359",
                "대표이미지" : "bj_2300_1.png",
            },
            {
                "분류" : "Daikstra DP",
                "제목": "외판원 순회3",
                "문제": "모든 도시를 한번씩 순회하여 제자리로 돌아오는 최소경로 구하기",
                "해법": "2차원 daikstra DP 이긴 한데 비교대상이 소수형 값임을 주의해야 한다." +
                "\n 1) 소수점 값 비교 : 두값의 차이가 1e-9 보다 큰지 작은지 비교" +
                "\n 2) 소숫점 출력 precision 을 적절하게 설정 cout.precision(10) 정도로 설정" +
                "\n 3) 너무 크지 않는 DP 초기값설정 DOUBLE_MAX = (double)(1e12)",
                "문제링크" : "https://www.acmicpc.net/problem/16991", 
                "코드링크" : "https://www.acmicpc.net/source/82610321",
            },
            {
                "분류" : "누적합",
                "제목": "Pedometer",
                "문제": "원형의 길에 놓여있는 휴계소를 시계방향으로만 이동이 가능할때 모든 위치 쌍들의 이동거리중 M 의 배수가 되는 쌍의 개수를 구하는 문제",
                "문제이미지" :  "abc_367_d_2.png",
                "해법": "나열된 거리들의 누적합테이블을 만든다.(0 포함)." +
                "\n 1) 누적합 r 번째 S[R] 에대해 M 으로 나눈 나머지가 같은 S[L] (L 은 0 부터 R-1) 의 개수를 구한다. a-> b 로 이동(a<b) 케이스" +
                "\n 2) 전체 이동 길이를 L 이라 했을 때 L-S[R] 에 대해 M 으로 나눈 나머지가 같은 S[L] 도 추가로 구하여 더한다. b->a 로 이동케이스",
                "문제링크" : "https://atcoder.jp/contests/abc367/tasks/abc367_d", 
                "코드링크" : "https://atcoder.jp/contests/abc367/submissions/56868157",
                "대표이미지" : "abc_367_d.png"
            },
            {
                "분류" : "DP",
                "제목": "Permute K times",
                "문제": "규칙에 따른 배열 재배치 함수가 정의 되어있을때 K 번 했을때 원래 배열이 어떻게 재배치 되는지 찾는 문제",
                "해법": "K 가 최대 10^18 까지 이므로 단순히 DP 같은것으로 풀 수 없다." +
                "\n 재배치 함수를 2^T 번 수행하였을때 함수를 DP Table 로 만든 후 K 를 각 비트자리가 1인 부분을 찾아서 변환함수를 합셩하면 된다.", 
                "문제링크" : "https://atcoder.jp/contests/abc367/tasks/abc367_e", 
                "코드링크" : "https://atcoder.jp/contests/abc367/submissions/56899595",
                "대표이미지" : "abc_367_e.png"
            },
            {
                "분류" : "누적합 + DP",
                "제목": "게임판",
                "문제": "전체 게임판을 정해진 크기의 SubWindow 를 왼쪽 상단에서 오른쪽 하단까지 슬라이딩 하면서 " + 
                "각 윈도우의 1,2 로마킹된 위치와 중앙 위치의 거리의 합의 차이가 최소가 얼마인지 구하는 문제",
                "문제이미지" :  "bj_29892_2.png",
                "해법" : "1 by SubWin sz 의 배열의 합을 계산한다고 생각해보면 DP[i][j][k] 는 i,j 의 배열이 중심점이 K 인 지점과 거리의 함으로 정의한다. " +
                "\n 계산을 줄이기 위해서 DP[i+1][j][k] 는 DP[i][j][k] 를 참조하여 업데이트 해 주어야 하는데 이때 전체윈도우의 각 열별로 각 그룹별 숫자의 개수를" +
                "\n 누적합으로 미리계산해야 한다. data[i][j] 의 값만큼 뻬주고, data[i+sz][j] 값만큼 더해주고 중간은 반으로 나누어 위는 개수만큼 더해주고" + 
                "\n 아래는 개수만큼 뻬주어야 한다.", 
                "문제링크" : "https://www.acmicpc.net/problem/29892", 
                "코드링크" : "https://www.acmicpc.net/source/82932354",
                "대표이미지" : "bj_29892.png"
            },

            {
                "분류" : "우선순위큐",
                "제목": "가운데를말해요",
                "문제": "숫자배열이주어지면 크기순 정렬하여 중앙값을 출력해야 하는 문제 ", 
                "해법" : "우선순위 큐를 2개 만들고 왼쪽 큐는 제일 큰수가 Top 으로 , 오른쪽 큐는 제일 작은 수가 Top 으로 오게 설정함." +
                "\n 새로운 숫자가 들어오면 완쪽 큐의 Top 과 비교하여 더 작거나 같으면 왼쪽에넣고 그렇지 않으면 오른쪽에 넣음" +
                "\n 항상왼쪽 큐의 크기가 오른쪽 큐의 크기와 같거나 1크게 유지되어야 하므로 사이즈가 큰 큐에서 작은큐로 옮겨주면서 벨런스를 맞춰주면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/1655", 
                "코드링크" : "https://www.acmicpc.net/source/83207504"
            },
            {
                "분류" : "우선순위큐, DP",
                "제목": "데이터 분석",
                "문제": "2차원 좌표에 여러 점들이 있고 가로선을 서로 겹치지 않게 그었을때 점과 선사이의 거리가 최소가 되는 값을 구하는 문제", 
                "문제이미지" :  "bj_29893.png",
                "해법" : "점들을 X 좌표 기준으로 정렬하여 어떻게 그룹핑하면 최적화가 될지 찾아야 하는문제. 각 그룹은 선분이 그룹의 중앙값에 위치해야함" +
                "\n 중앙값은 각그룹에서 X 순으로 정렬했을때 중간번째 좌표의 값으로 삼으면 됨." +
                "\n 정렬후 1~k 까지의 최소값은 다음과 같이 구할 수 있다." +
                "\n DP[k] = 모든 n 에 대해서 min(DP[i + n] + 중앙값과차이의합(1+n~K))",
                "문제링크" : "https://www.acmicpc.net/problem/29893", 
                "코드링크" : "https://www.acmicpc.net/source/83211594"
            },
            {
                "분류" : "유니온 파인드",
                "제목": "카드게임",
                "문제": "철수가 임의의 숫자 카드를 낼때 민수가 갖고있는숫자중 철수의 카드보다 더큰 카드 중에서 가장 작은 값의 카드를 선택하는 문제", 
                "해법" : "한번 카드를 내면 다시 낼 수 없기 때문에 정렬후 카드를 찾아 내고나면 union find 를 이용해 n 과 n+1 을 묵어주면 된다." +
                "\n 다만 union find 를 수행할때 더큰값이 작은 값의 parent 가되게 설정해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/16566", 
                "코드링크" : "https://www.acmicpc.net/source/83274029"
            },

            {
                "분류" : "다익스트라 DP, Greedy",
                "제목": "현대모비스 트럭 군집주행",
                "문제": "도로에서 한지점에서 출발하여 각 지점까지의 거리의 합이 최소가 되는 값을 구해야 한다. 단 선두차량을 뒤따라 갈경우 10% 비용이 절감된다.", 
                "문제이미지" : "bj_31938.png",
                "해법" : "다익스트라 DP 를 통해 모든 거리의 합을 구할 수 있다. 이때 모든 차량은 선두로 가지 않는다고 가정한다" +
                "\n 모든 도작치점으로 도착하는 마지막 길이 선두로 가는 길이라 가정하고 각 도착지점마다 마지막 Edge 를 감안하여 더해주면된다." +
                "\n 그러나 여기에 함정이 있는게 임의이 지점으로 들어오는 경로의 길이가 같은게 두가지 이상일 수 있다는 것이다. 이때에는 마지막 경로의 길이가" +
                "\n 가장 짧은것을 선택하면된다. DP 값을 pair 로 설정하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/31938", 
                "코드링크" : "https://www.acmicpc.net/source/83283303"
            },
            {
                "분류" : "DP",
                "제목": "아이템2",
                "문제": "N 개의 수열에서 크기가 K 인 집계로 숫자를 반복해서 집을 때 최대 값이 되는 경우를 찾는 문제", 
                "해법" : "DP[i][1] i-1 번째까 묶였을때의 최대값, DP[i][0] : i-1 번째가 묶이지 않았을때의 최대값",
                "문제링크" : "https://www.acmicpc.net/problem/31838", 
                "코드링크" : "https://www.acmicpc.net/source/83979723",
                "대표이미지" : "bj_31838.png"
            },
            {
                "분류" : "누적합, 투포인터",
                "제목": "일꾼고용",
                "문제": "일꾼들의 그룹ID(1 또는 2) 와 능력치가 주여졌을때 두 그룹간 일꾼의 숫자가 같고 능력치의 차이가 K 이하가 되는 연속하는 부분수열의 개수를 구하는 문제", 
                "해법" : "각 일꾼수열에 대해 누적합을 게산하여 누적합이 같은 것들끼리 는 일꾼의 숫자가 같음을 의미한다. 각 그룹별로 능력치 합의 차이가 K 이하인 개수를 구하면 된다." +
                "\n 그룹내 특성이 K 이하인 쌍을 구하기 위해서는 투포인터를 이용하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/32125", 
                "코드링크" : "https://www.acmicpc.net/source/83539417"
            },
            {
                "분류" : "이분 그래프",
                "제목": "이분 그래프",
                "문제": "주어진 그래프가 이분 그래프인지 판별하는 문제", 
                "해법" : "BFS 로 임의의 노드에 출발해서 인접한 노드들끼리 0,1 서로 다른 값을 가질 수 있는 지 체크하면 된다. 예를 들면 1로 마킹된 노드에 다시" +
                "\n 0 으로 마킹되어야 할일이 생기는 지 검사하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/1707", 
                "코드링크" : "https://www.acmicpc.net/source/83612758"
            },
            {
                "분류" : "이분 그래프",
                "제목": "줄다리기",
                "문제": "N 명의 인원들을 2팀으로 나누는데 팀 구성원간 최소 팀워크가 최대인 값이 얼마인지 찾는 문제", 
                "해법" : "팀워크가 큰 구성원쌍을 내림차순으로 정렬하여 이분그래프를 구성하면서 더이상 이분그래프를 만들수 없는 쌍의 팀워크가 정답임.",
                "문제링크" : "https://www.acmicpc.net/problem/31444", 
                "코드링크" : "https://www.acmicpc.net/source/83614273"
            },
            {
                "분류" : "DP",
                "제목": "RPG",
                "문제": "N 개의 퀘스트가 있고 그 퀘스트를 클리어하면 보상이 주어지는데 최대한 깰수있는 퀘스트의 개수를 구하는 문제", 
                "해법" : "지능과 힘에 도달하였을때 총 깰수있는 퀘스트 갯수를 구하고 각 지능과 힘에 도달할 수 있는 지 검사하면 된다." +
                "\n 각 지능과 힘의 상태에 도달햇을때 잔여 스텟을 계산하여 이전가능한 상태에서 현재상태로 올수 있는지 계산하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/1315", 
                "코드링크" : "https://www.acmicpc.net/source/83781904"
            },
            {
                "분류" : "위상정렬",
                "제목": "부분달리기 시합",
                "문제": "N 명이 달리기 시합을 하고 M 개의 쌍의 달리기 실력쌍이 주어질때 모든 사람의 순위를 결정할 수 있는 가능한 모든 부분배열을 구하는 문제", 
                "해법" : "더 빠른 사람을 부모노드, 느린사람을 자식노드로 생각하여 모든 사람의 자식노드들을 리스트 할 수 있다. 그리고 위상정렬로 노드순서를 재배치" +
                "\n 할 수 있고 정렬된 순서로 DP[i] = DP[All child] + 1 로 계산할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/31445", 
                "코드링크" : "https://www.acmicpc.net/source/83946517",
                "대표이미지" : "bj_31445.png"
            },
            {
                "분류" : "DP",
                "제목": "선분의 합집합",
                "문제": "각 선분 별로 길이와 가격이 있고 주어진 가격으로 선분을 딱 맞게 구매하여 원하는 길이를 만들 수 있는지 계산해야 하는 문제", 
                "해법" : "선택된 선분의 집합에서 최소 길이는 가장 긴선분의 길이, 최대길이는 모든 선분 길이의 합으로 정의할 수 있다." +
                "\n 선분들을 길이 순으로 정렬하여 DP[i][k] = i 번째 까지 K 의 가격으로 만들 수 있는 최대 길이로 정의 할 수 있다." +
                "\n 각 쿼리별로 DP 들을 순회하면서 i번째 선분의 길이 ~ DP[i][k] 에 속하는게 있으면 YES , 그렇지 않으면 NO 를 출력하면 된다." +
                "\n DP[i][k] 에서 i 번째 선분이 가격에 포함되지 않는 경우는 고려하지 않아도 된다. 만약 i 번째 선분의 길이가 10이고, " +
                "\n 가격 k 를 만드는 최대 선분길이가 8 인경우 DP[i][k] 를 스캔하여 9,K 는 NO 로 답할거라고 생각할 수도 있지만" +
                "\n 해당 쿼리는 DP[j][k] (j < i)를 스캔하여 YES 를 도출 할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/31445", 
                "코드링크" : "https://www.acmicpc.net/source/83946517"
            },
            {
                "분류" : "LCA, Sparse Table",
                "제목": "도로 네트워크",
                "문제": "트리구조로 되어있는 도로망에서 Node A,B 간 거쳐가는 간선들의 min, max 를 빠르게 찾아야 하는 문제", 
                "해법" : "Sparse Table 을 구성하여 LCA 를 빠르게 구할 수 있다. 모든 Node 별로 2^k 만큼 떨어진 부모위 위치를 캐싱하면 된다." +
                "\n P[K][i] 는 K 번째 노드의 2^i 승 위치만큼 떨어진 부모노드를 가리킨다고 생각해보면 아래와 같이 구할 수 있다." +
                "\n P[K][i] = P[P[K][i-1]][i-1]" +
                "\n 즉 만약 i = 4 이라면 현재노드의 16번째 조상은, 8번째 조상의 8번째 조상이라는 원리이다.",
                "문제링크" : "https://www.acmicpc.net/problem/3176", 
                "코드링크" : "https://www.acmicpc.net/source/84107642",
                "대표이미지" : "bj_3176.png"
            },
            {
                "분류" : "stack",
                "제목": "Buildings",
                "문제": "N개의 빌딩이 있고 1~N 의 i 에 대해서 j i~j 사의 빌딩중 제일 큰 j 가 몇개나 있는지 각각 찾는 문제 ", 
                "해법" : "이 문제를 다시 해석하면 i+1 번째의 높이에서 바라보았을때 보이는 빌딩이 총 몇개인지 찾아야 하는 문제이다." +
                "\n 이 문제를 해결하기 위해서 모노토닉 스택이 필요하고 맨 뒤에서 부터 높이가 낮아지는 stack 을 구성해야 한다." +
                "\n 뒤에서 부터 순회하면서 stack top 보다 현재 빌딩이 더 높으면 stack 을 pop 하며 monotonic 을 유지하며 stack 의 크기를 계산해서 출력하면된다.",
                "문제링크" : "https://atcoder.jp/contests/abc372/tasks/abc372_d", 
                "코드링크" : "https://atcoder.jp/contests/abc372/submissions/58061510",
                "대표이미지" : "abc372_d.png"
            },
            {
                "분류" : "union-find",
                "제목": "K-th Largest Connected Components",
                "문제": "N 까지의 정수 집합이 있고 두가지의 쿼리가 있는데 첮째는 union, 두번째는 union 에서 K 번재로 큰 값이 무엇인지 찾는문제이다", 
                "해법" : "K 의 제약이 10이하인것이 힌트이다. union find 를 응용하여 N 개의 이차원 배열을 만들어 union 이 될때마다 각 2차원 배열을" +
                "\n 합치고 정렬하면 된다. K 가 최대 10 이므로 정렬 이후 10개로 resize 하면 된다.",
                "문제링크" : "https://atcoder.jp/contests/abc372/tasks/abc372_e", 
                "코드링크" : "https://atcoder.jp/contests/abc372/submissions/58061510"
            },
            {
                "분류" : "DFS",
                "제목": "Hidden Weight",
                "문제": "그래프가주어지고 Node 간 값의 차이가 Edge 로 주어진다. 이때 모든 Edge 를 만족하는 Node 값의 List 를 구하여야 한다.", 
                "해법" : "단방향 그래프이지만 Weight 에 -1 을 곱하면 반대 방향의 Eedg 가 성립하기때문제 양뱡향으로 그래프를 구성한다." +
                "\n 임의의 노드에서 출발하여 모든 Node 를 방분할 때 까지 DFS 로 순회하면서 Edge 의 값에 따라 Node 를 update 하면 된다." +
                "\n Weight 가 모순되는 경우는 없기 때문이다.",
                "문제링크" : "https://atcoder.jp/contests/abc373/tasks/abc373_d", 
                "코드링크" : "https://atcoder.jp/contests/abc373/submissions/58320807"
            },
            {
                "분류" : "오일러 경로 테크닉",
                "제목": "회사 문화 2",
                "문제": "트리구조의 회사 조직에서 상사가 칭찬을 받으면 부하까지 같이 칭잔을받을때 특정 시점에서 직원의 총 칭찬점수가 몆점인 지 구하는 문제.", 
                "해법" : "오일러 경로 테크닉과 구간합을 이용하면 본 문제를 쉽게 해결할 수 있다. 트리를 DFS 로 순회하면서 노드에 진입하는 번호와 나오는 번호를 마킹한다." +
                "\n 칭칸쿼리를 받으면 해당 사원의 진입번호에 값을 증가 나오는 번호에 값을 감소 시킨다." +
                "\n k 번재 사윈의 칭찬값은 1~ K 번째 사원의 진입번호 까지의 총합이고 이는 Fanwick Tree 로 구현할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/14268", 
                "코드링크" : "https://www.acmicpc.net/source/84687277",
                "대표이미지" : "bj_14268.png"
            },
            {
                "분류" : "오일러 경로 테크닉",
                "제목": "Count Descendants",
                "문제": "주어진 Tree 에서 특정 노드의 자식들 중 Level 이 K 인 노드들의 개수를 찾는 문제", 
                "해법" : "오일러 경로 테크닉으로 각 노드들의 tin, tout 을 저장한다. 모든 노드들의 tin 값을 level 단위로 list 한다." +
                "\n 주어진 노드들의 tin ~ tout 사이의 값에 의해 해당되는 레벨리스트에서 lower bound 를 이용하여 개수를 구할 수 있다.",
                "문제링크" : "https://atcoder.jp/contests/abc202/tasks/abc202_e", 
                "코드링크" : "https://atcoder.jp/contests/abc202/submissions/58591728",
            },
            {
                "분류" : "DP",
                "제목": "Range Flip Find Route",
                "문제": "2차원 배열에서 White 영역과 Bloack 영역이 있고 White 영역으로만 이동이 가능하다. (x1,y1) ~ (x2,y2) 까지 사각형 단위로 색상을 반전 시킬 수 있다." +
                "\n (1,1) -> (H,W) 까지 이동하기 위해 최소한의 반전횟수를 구하는 문제", 
                "해법" : "1,1 에서 H,W 까지 경로에 연속된 검은 칸은 한번에 반전 시킬 수 있다. 따라서 (1,1) -> (H,W) 까지 최소 색 반전의 개수를 DP Table 로 구성하면 된다." +
                "\n 단 시작칸과 도착칸이 검은색일 경우 반전해야 하므로 DP 값을 추가로 1 증가시켜야 한다." +
                "\n 최종답은 DP[H-1][W-1] / 2 가 된다. 색이 2번 반전되는 것은 검은색 그룹이 1개라는 뜻이기 때문.",
                "문제링크" : "https://atcoder.jp/contests/agc043/tasks/agc043_a", 
                "코드링크" : "https://atcoder.jp/contests/agc043/submissions/58516066",
                "대표이미지" : "agc043_a.png"
            },
            {
                "분류" : "DP",
                "제목": "동전 분배",
                "문제": "동전이 주어지고 주어진 동전을 적당히 나누어 정확히 금액을 반으로 나눌 수 있는 지 문제",
                "해법" : "DP[i][K] = i 번째 동전까지 K 원을 만들 수 있는지 여부를 저장하는 배열로 정의하여 DP[N][총합의반] 을 출력하면 된다." +
                "\n 약간의 트릭을사용하여 1차원 DP 로 처리할 수도 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/1943", 
                "코드링크" : "https://www.acmicpc.net/source/85072021"
            },
            {
                "분류" : "DP",
                "제목": "양팔저울",
                "문제": "N 개의추가 주어졌을때 새로운 추의 무게를 확인 할 수 있는지 판단하는 문제. 양팔저울이 평행이 되도록 적절히 추를 배치하면 " +
                "\n 새로운 추의 무게가 측정 가능한지 판단할 수 있다." ,
                "해법" : "DP[i][K] = i 번째 추 까지 고려했을때 만들 수 있는 무게 차이가 K 이면 1 로 정의 할 수 있다." +
                "\n DP[i-1][k] 가 1일때 DP[i][X] 가 1이되는 조건은 3가지 이다. K, K+ms[i], abs(k-ms[i])" +
                "\n i 번째 추를 놓지 않는경우, i번째 추를 무거운 쪽에 놓는경우, i 번재 추를 가벼운 쪽에 놓는 경우" + 
                "\n DP[i-1] 와 별개로 i 번째 추만 한쪽에 올려놓는 경우가 있음.",
                "문제링크" : "https://www.acmicpc.net/problem/2629", 
                "코드링크" : "https://www.acmicpc.net/source/85093221"
            },
            {
                "분류" : "DP",
                "제목": "사탕가게",
                "문제": "N 가지의 사탕별로 단가가 있고 주어진 예산으로 최대 칼로리를 구하는 문제, 종류별 사탕의 제한이 없다. ",
                "해법" : "종류별 개수의 제한이 없을 경우에는 1차원 DP 로테이블을 만들 수 있다." +
                "\n DP[k] 예산을 K 만큼 사용하였을때 최대 칼로리로 정의 한다." +
                "\n 가능한 모든 i 와 k 에 대하여 DP[k] = max(DP[k], DP[k- i번째 사탕의 가격] + i번째 사탕의 칼로리) 로 업데이트 해 주면 된다", 
                "문제링크" : "https://www.acmicpc.net/problem/4781", 
                "코드링크" : "https://www.acmicpc.net/source/85099169"
            },
            {
                "분류" : "DP",
                "제목": "수강과목",
                "문제": "전형적인냅색 문제 중요도를 최대화할 수있도록 시간을 분배하는 방법 찾기 ",
                "해법" : "DP[i][k] : i 번째까지 고려하여 K 시간을 썼을 때 최대 중요도" +
                "\n 모든K 에 대해서 DP[i][k] = max(DP[i-1][k], DP[i-1][k-W] + C) 로 계산하여 업데이트 하면된다." +
                "\n DP[0] 을 dummy 로 define 하고 index 를 조절하면 좀더 간결하게 dp table 을업데이트 할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/17845", 
                "코드링크" : "https://www.acmicpc.net/source/85126535"
            },
            {
                "분류" : "union find",
                "제목": "Sakurako, Kosuke, and the Permutation",
                "문제": "N 개의 수열에서 F(A[i]) = i , F(F(A[i])) = 1 인 원소들로 구성된 수열을 만드는데 원소들끼리 swap 을 몇번해야 하는 지 찾는 문제" +
                "\n 예를 들면 {5,4,3,2,1} 에서 F(1) = 5 , F(2) = 4 , F(3) = 3 , F[4] = 2 , F[5] = 1 이고 F(F(5)) = 5 .... F(F(1)) = 1 이므로 답은 0 이다." +
                "\n {5,4,3,2,1} 같은 수열을 만들기 위해 원소를 몇번 swap 해야 하는지 찾아야 한다.",
                "해법" : "모든원소들은 F(x) 를 몇번 합성하냐에 따라 방향 그래프로 표현할 수 있다. 각 그래프별 cycle 의 개수에 따라 (S-1)/2 만큼 swap 이 필요하다." +
                "\n S는 cycle 의 크기이다.",
                "문제링크" : "https://codeforces.com/contest/2033/problem/E", 
                "코드링크" : "https://codeforces.com/contest/2033/submission/288058940",
                "대표이미지" : "force_2033_E.png"
            },
            {
                "분류" : "union find, 그리디, 그래프 이론",
                "제목": "색깔 모으기",
                "문제": "2개짜리 박스가 N 개 있고 빈 박스가 추가로 1개 있을때 주어진 조건에 따라 공을 이동시켜 모든 박스에 동일한 공으로 채울 수 있는지 판단하는 문제" +
                "\n 채울 수 있으면 이동횟수를 , 그렇지 않으면 -1 을 출력해야 한다. 공을 빈곳으로 이동하거나 같은 번호로 이동할 수 있다.",
                "해법" : "아래의 2 단계로 도출 할 수 있다." +
                "\n 1) union find 등을 이용하여 서로 의존성이 없는 박스들끼리 모은다. 전체 답은 각 그룹들의 합으로 구성할 수 있다." +
                "\n 2) 각 박스들의 위의 구슬 이 아래 구슬을 뻬는데 의존성이 있기 때문에 위의 구슬 -> 아래 구슬의 방향 그래프로 표현할 수 있다." +
                "\n 방향그래프를 구성하는 노드들의 indegree 가 0 인게 2개 이상일 경우 결과를 만들 수 없다. 그리고 방향그래프의 노드 개수 + 1 이 이동횟수이다.",
                "문제링크" : "https://www.acmicpc.net/problem/32070", 
                "코드링크" : "https://www.acmicpc.net/source/86124674",
                "대표이미지" : "bj_32070.png"
            },
            {
                "분류" : "우선순위큐",
                "제목": "트리뽑아내기",
                "문제": "트리에서 정해진 조건으로 Root 를 뽑아낼때 뽑히는 노드 순서대로 출력하는 문제" +
                "\n 루트를 뽑은 후 자식노드들 중 제일 작은 Node 가 Root 가 되고, leaf 노드까지 연쇄적으로 이동한다.",
                "해법" : "관찰만 잘하면 구현은 간단한 문제" +
                "\n 1) 우선 순위 큐를 이용하여 뽑을 대상이 되는 노드들을 잘 관리하고 매번 뽑을 때 마다 뽑은 노드의 자식들을 큐에 넣어 주면 된다",
                "문제링크" : "https://www.acmicpc.net/problem/32072", 
                "코드링크" : "https://www.acmicpc.net/source/86200470",
                "대표이미지" : "bj_32072.png"
            },
            {
                "분류" : "누적합, FanWickTree",
                "제목": "Mod Sigma Problem",
                "문제": "주여진 배열의 모든 부분 배열의 합의 Mod M 의 총합을 구하는 문제",
                "해법" : "부분 배열의 합을 빠르게 계산히기 위해서는 먼저 누적합을 구해야 한다.",
                "문제링크" : "https://atcoder.jp/contests/abc378/tasks/abc378_e", 
                "코드링크" : "https://atcoder.jp/contests/abc378/submissions/59786682",
            },
            {
                "분류" : "Greedy, Union Find",
                "제목": "Sum of Max Matching",
                "문제": "그래프가 주어지고 각 Edge 는 양 방향이며 고유의 weight 를 가지고 있다." +
                "/n 노드 x,y 에대한 경로는 경로에 포함되는 Edge 들의 최대 weight 로 정의하며, F(x,y) 는 x 에서 y 로 가는 모든 경로중 최소값으로 정의한다." +
                "/n K개의 노드 그룹이 주어지고 각 그룹의 노드들끼리 임의의 순서로 1:1 매칭하여 F(x,y) 의 합을 구할때 최소가 되는 합을 구해야 한다.",
                "해법" : "1) 각 그룹의 index 별로 count 변수를 정의한다" +
                "\n 2) 노드 개수만큼 unionFind 클래스를 생성한다." +
                "\n 3) Edge 들을 weight 크기순으로 정렬하여 순회하여 Edge 에 연결된 node 들의 union 여부를 판단한다" +
                "\n 4) 만약 union 이 아닌경우 두 Node 의 root 에 대한 A,B ground 의 최소값 만큼 ans 를 업데이트 해 준다" +
                "\n 5) root node 에 A,B ground 의 최소값 만큼 차감한다." ,
                "문제링크" : "https://atcoder.jp/contests/abc383/tasks/abc383_e", 
                "코드링크" : "https://atcoder.jp/contests/abc383/submissions/60629616",
            }
        ];

        // 줄바꿈 문자를 <br> 태그로 변환하는 함수
        function nl2br(str) {
            return str.replace(/\n/g, '<br>');
        }

        // JSON 배열의 각 행을 개별 HTML 테이블로 변환하는 함수
        function jsonToIndividualTables(jsonArray) {
            const container = document.createElement('div');

            jsonArray.forEach((item, index) => {
                const table = document.createElement('table');

                // 테이블 헤더 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = Object.keys(item);
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // 테이블 바디 생성
                const tbody = document.createElement('tbody');
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    // 줄바꿈 문자를 <br> 태그로 변환하여 innerHTML에 할당

                    if (header === '문제링크' || header === '코드링크') {
                        const link = document.createElement('a');
                        link.href = `${item[header]}`;
                        if (item[header] == '아직못품')
                            link.textContent = '아직못품';
                        else
                            link.textContent = 'CLICK';
                        link.target = '_blank';
                        td.appendChild(link);
                    } else if(header == "대표이미지" || header == "문제이미지") {
                        const img = document.createElement('img');
                        img.src = item[header];
                        td.appendChild(img);
                    }
                    else {
                        td.innerHTML = nl2br(item[header].toString());
                    }
                    row.appendChild(td);
                });
                tbody.appendChild(row);
                table.appendChild(tbody);

                // 짝수 인덱스 테이블에 클래스 추가
                if (index % 2 === 0) {
                    table.classList.add('table-even');
                } else {
                    table.classList.add('table-odd');
                }

                container.appendChild(table);
            });

            return container;
        }

        // 개별 테이블을 페이지에 추가
        const tableContainer = document.getElementById('table-container');
        const tables = jsonToIndividualTables(jsonData);
        tableContainer.appendChild(tables);
    </script>

</body>
</html>
