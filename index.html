<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Rows to Individual HTML Tables</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px; /* 각 테이블 간의 공백을 설정 */
        }
        table, th, td {
            border: 1px solid black;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
        .table-odd {
            background-color: #f2f2f2;
        }
        .table-even {
            background-color: #ffffff;
        }
    </style>
</head>
<body>

    <div id="table-container"></div>

    <script>
        // JSON 데이터
        const jsonData = [
            {
                "제목" : "E - Tree and Hamilton Path 2",
                "문제": "트리의 모든 노드를 한번씩 순회하였을때 최단 거리를 찾는 문제", 
                "해법": "전체 길의의 합 * 2 - (트리의 지름). \n트리의 지름구하는 방법은" + 
                "\n1) 임의의 노드를 Root 로 잡고 에서 제일 긴 노드 찾기." + 
                "\n2) 제일 긴 노드를 Root 를 젭고 해당 노드에서 제일 긴 거리를 찾으면 그것이 곧 트리의 지름이 된다", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_e", 
                "코드링크" : "https://atcoder.jp/contests/abc361/submissions/55343394",
                "대표이미지" : "abc361_f.png"
            },
            {
                "제목": "G - Go Territory",
                "문제": "검은돌의 좌표가 주어지고 만약 어떤 빈곳에 흰돌이 놓여있다면 잡힐 수 밖에 없는 영역의 개수를 구하는 문제", 
                "해법": "세로로 스위핑 하면서 각 줄별로 연속된 빈곳을 영역으로 구분함(L 과 R 의 구조체)" + 
                "\n2) 각줄별로 현재줄과 다음줄 을 비교하여 위아래로 겹치는 영역끼리 합친다(영역별로 ID 를 부여하여 union-find 로 합침)" + 
                "\n2) -1,-1 이 있는 지점의 ID 와 같지 않은 영역들의 크기의 합을 계산하면 답이된다.", 
                "문제링크" : "https://atcoder.jp/contests/abc361/tasks/abc361_g", 
                "코드링크" : "아직못품",
                "대표이미지" : "abc361_g.png"
            },
            {
                "제목": "경찰차",
                "문제": "2차원 공간에 경찰자가 이동하여 사건을 해결하는데 최소한한의 이동거리와 1,2 경찰자중 각각 어떤 경찰차를 선택해야 하는지 결정하는 문제", 
                "해법": "DP[i][j] 는 1 번, 2번 경찰자의 마지막 처리 위치이며, DP[max(i,j)+1][j] = DP[i][j] + 거리(i -> max(i,j)+1)" + 
                "\n2) 로 계산할 수 있다. 각 DP 값이 갱신될 때마다 어디서 이동했는지 기록한다.",
                "문제링크" : "https://www.acmicpc.net/problem/2618", 
                "코드링크" : "https://www.acmicpc.net/source/81325734",
                "대표이미지" : "bj_2618.png"
            },
            {
                "제목": "사전",
                "문제": "N개의 a 와 M 개의 z 의 조합으로 문자열을 만들때 K 번째 문자열은 무엇인가?", 
                "해법": "DP[i][j] 는 a의 갯수가 i 개이고 b의 개수가 j 일때 가능한 모든 문자열의 개수로 정의한다." + 
                "\n2) 만약 DP[i-1][j] 보다 K 가 더 크면 i+j 번째 문자열은 z 이다. 이런식의 크기비교로 순서대로 a,z 여부를 판단할 수 있다." +
                "\n2) 단 DP 테이블 값이 너무 커져서 오버플로우가 나면 비교에 문제가 생기기 때문에 K 의 범위보다 큰 값을 정의해서 해당 값이 넘어가지 않게 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1256", 
                "코드링크" : "https://www.acmicpc.net/source/81381697",
                "대표이미지" : "bj_1256.png"
            },
            {
                "제목": "로봇 조종하기",
                "문제": "2차원 공간을 좌,우, 하로 이동이 가능할때 (1,1) -> (R,C) 로 이동하면서 최대한 이득을 낼수 있는 값은 얼마인지 찾는 문제", 
                "해법": "DP[i][j] 는 1,1 에서 ij 로 왔을때 최대값을 의미함." + 
                "\n위에서 내려왔을때의 값, 왼쪽에서왔을때의 값, 그리고 오른쪽에서 왔을때의 값중 최대값을 선택하면 된다." +
                "\n위에서 왔을때의 값은 DP[i-1][j] 이며, 왼쪽에서, 또는 오른쪽에서 스윕하면서 L[j], R[J] 를 계산해 주어야한다" + 
                "\nDP[i][j] = max(L[j], R[J]) 로 도출할 수 있다. ",
                "문제링크" : "https://www.acmicpc.net/problem/2169", 
                "코드링크" : "https://www.acmicpc.net/source/81392028",
                "대표이미지" : "bj_2169.png"
            },
            {
                "제목": "우수 마을",
                "문제": "다음 조건을 만족하는 최대 값을 구해야함." +
                "\n 1) 부모자식은 동시 선택안됨." +
                "\n 2) 모든 노드는 선택된 노드와 최소 하나와 연결되어야함.", 
                "해법": "DP[0][idx] = idx 노드가 선택안되었을때 최대값, DP[1][idx] = idx 가 선택되었을때 최대값" +
                "\n 최대값을 구하려면 사실 2번조건은 고려하지 않아도 됨. 왜냐하면 인접한 3개의 노드가 동시에 선택안될 경우는 없기 때문.",
                "문제링크" : "https://www.acmicpc.net/problem/1949", 
                "코드링크" : "https://www.acmicpc.net/source/81643593",
                "대표이미지" : "bj_1949.png"
            },
            {
                "제목": "트리의 독립집합",
                "문제": "앞의 문제와 동일한데 선택된 노드 집합을 구해야 함.",
                "해법": "1번노드부터 DFS 로 추적해서 결과에 노드를 쌓아야 한다." +
                "\n1)만약 DP[1][i] > DP[0][i] 이면 현재 노드 선택" +
                "\n2)모든 자식노드들을 검사하여 만약 현재 노드가 선택되었을경우 자식노드들은 선택하지 않는다." +
                "\n3)모든 자식노드들을 검사하여 만약 현재 노드가 선택되지 않는경우 DP[1][next] > DP[0][next] 일경우 자식노드들을 선택한다",
                "문제링크" : "https://www.acmicpc.net/problem/2213", 
                "코드링크" : "https://www.acmicpc.net/source/81656137",
            },
            {
                "제목": "도로포장",
                "문제": "그래프의 최단 거리를 구해야 하는 문제이지만, 최대 K 개 까지 도로포장을 통해 길이를 0 으로 만들 수 있다.",
                "해법": "다익스트라를 응용하여 DIST[dest][포장한갯수] 로 확장하여야 한다." +
                "\n PQ 에 넣을 때 포장할 경우와 포장하지 않을 경우 2가지를 고려해야 함.",
                "문제링크" : "https://www.acmicpc.net/problem/1162", 
                "코드링크" : "https://www.acmicpc.net/source/81680485",
            },
            {
                "제목": "다이아몬드 광산",
                "문제": "맵에서 가장 큰 다이아 몬드를 찾는 문제",
                "문제이미지" : "bj_1028.png",
                "해법": "각점애서 좌하, 또는 우하로 이여지는 1의 개수가 몇개인지 DP 로 쌓은 후 부르트 포스로 최대 값을 구핼 수 있다." +
                "\n단 DP 테이블을 만들때에는 아래에서 위로 스윕해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1028", 
                "코드링크" : "https://www.acmicpc.net/source/81751083",
            },

            {
                "제목": "이항계수4",
                "문제": "N, R, P 가 주어졌을때 이항계수binaryCoeff(N,R) 을 P 로 mod 한 값을 찾는 문제",
                "해법": "뤼카의 정리를 이용하며 쉽게 계산할 수있다." +
                "\n뤼카의 정리 : N,R 을 P 진수로 표현할때 각자리수 별로 이항계수를 구하여 곱한 것과 통일하다.",
                "문제링크" : "https://www.acmicpc.net/problem/11402", 
                "코드링크" : "https://www.acmicpc.net/source/81760595",
                "대표이미지" : "bj_11402.png",
                "참고" : "그림의 괄호는 행렬이 아니라 이항계수를 의미함"
            },
            {
                "분류" : "DP",
                "제목": "전구",
                "문제": "나열된 전구들의 색깔을 동일하게 맞출 수 있는 최소 방법 을 구하는 문제",
                "해법": "DP[S][E] = Min(DP[S][K] + DP[K+1][E]) + A  로 구할 수 있다. A 는 bulb[S] == bulb[K+1] 일 경우 0 그외는 1" +
                "\n비재귀로 풀려면 S 는 역순으로 순회해야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/11402", 
                "코드링크" : "https://www.acmicpc.net/source/81760595",
                "대표이미지" : "bj_2449.png",
            },
            {
                "분류" : "lazy segtree",
                "제목": "구간 합 구하기 2",
                "문제": "구간 업데이트 및 Query 가 필요하므로 Lazy Segtree 가 적용되어야 한다.",
                "해법": "Atcoder 의 Lazy Segtree 를 도입하여 업데이트및 Query 를 수행하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/10999", 
                "코드링크" : "https://www.acmicpc.net/submit/10999/78148216",
                "대표이미지" : "bj_10999.png",
            },
            {
                "분류" : "Fanwick tree\n(폔윅트리)",
                "제목": "구간 합 구하기 4",
                "문제": "원소 업데이트및 구간 합 쿼리를 해야함.",
                "해법": "펜윅트리를 이용하여 구간쿠리를 수행함. FW Tree 클래스 성질은 아래와 같다." +
                "\n index 0 은 미사용. 1부터~ N 까지 쿼리함." +
                "\n 쿼리시  S, E 둘다 포함됨.",
                "문제링크" : "https://www.acmicpc.net/problem/11659", 
                "코드링크" : "https://www.acmicpc.net/source/81789965",
            },
            {
                "분류" : "Fanwick tree\n(폔윅트리)",
                "제목": "중앙값",
                "문제": "N개의 수열에서 K 개만큼 시작부터 스윕해가면서 중앙값들의 합을 구하는 문제",
                "해법": "펜윅트리 에 대상 부분 수열을 넣었다 뻬기를 반복하면서 이진 탐색을 통해 중앙 번째의 값을 구할 수 있다." +
                "\n 입력값 제한이 65535 이므로 Tree 의 배열은 각 숫자들의 개수를 의미한다.",
                "문제링크" : "https://www.acmicpc.net/problem/1572", 
                "코드링크" : "https://www.acmicpc.net/source/81797697",
            },
            {
                "분류" : "DP",
                "제목": "전시장",
                "문제": "그림을 일렬로 전시하였을때 높이 차이가 S 이상 유지되는 그림만 가격이 매겨질때 최대 가격을 벌 수있는 경우가 얼마인지 찾는문제",
                "해법": "그림개수와 높이 제약이 너무 큰값이므로 DP 는 무조건 1차원 DP Table 이어야 한다." +
                "\n DP[i] 는 i 번째 그림이 판매가격에 포함되는 최대 가격으로 정의한다. 1부터 i-1 번째 까지 높이차가 S 이상 차이나는 최대 가격 + 현재 가격으로 도출할 수 있다." +
                "\n i+1 번째 그림 탐색시작은 i 번째 까지 탐색한 시점부터 탐색하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/2515", 
                "코드링크" : "https://www.acmicpc.net/source/81840975",
                "대표이미지" : "bj_2515.png",
            },
            {
                "분류" : "DP",
                "제목": "평범한 배낭",
                "문제": "표준적인 knapsack DP 문제",
                "해법": "DP[i][k] = i 번째 물건까지 사용한 용량이 K 일때 최대 만족도" +
                "\n DP[i][k] = max(DP[i-1][k] , DP[i-1][k-w[i]] + s[i] )" +
                "\n w[i] : i번째물건의 무게, s[i] : i 번째 물건의 만족도",
                "문제링크" : "https://www.acmicpc.net/problem/12865", 
                "코드링크" : "https://www.acmicpc.net/source/81851284",
            },
            {
                "분류" : "DP",
                "제목": "평범한 배낭",
                "문제": "knapsack DP 문제인데 각 물건은 N 개 까지 선택할 수 있음.",
                "해법": "각각의 물건의 크기를 2^n 의 집합으로 쪼갠 후(쪼갠 값들의 합은 물건의 개수와 같아야 한다.) " +
                "\n knapsack DP 로 풀이할 수 있다.",
                "문제링크" : "https://www.acmicpc.net/problem/12920", 
                "코드링크" : "https://www.acmicpc.net/source/81849885",
                "대표이미지" : "bj_12920.png",
            },
            {
                "분류" : "meet in the middle",
                "제목": "Parcel",
                "문제": "정수 List 에서 임의의 4개를 선택하여 합할시 Target 값이 존재하는지 판단하는 문제",
                "해법": "브루트포스로 풀면 N^3 이므로 시간내에 풀 수 없다. " +
                "\n 주어진 원소들 중에서 모든 원소쌍을 미리 Caching 해 놓은후 똑같이 순회하면서 인덱스 중복이 안되면서 각쌍의 합이 원하는 값인지 비교하면된다." +
                "\n 어떤 값을 만드는 원소 쌍은 단 하나만 Caching 해도 된다는 것이 핵심.",
                "문제링크" : "https://www.acmicpc.net/problem/16287", 
                "코드링크" : "https://www.acmicpc.net/source/81866971"
            },

            {
                "분류" : "포함배제의 원리",
                "제목": "N포커",
                "문제": "52장중 N 개의 카드를 뽑아서 포커가 나올 수 있는 경우의 수를 구하기",
                "해법": "52개의 경우중 N 장을 뽑는 모든 경우의 수를 DP 를 통해 미리 계산해 놓는다." +
                "\n 4장의 카드를 뽑고 나머지 카드 중 num-4 장의 카드를 뽑는 경우의 수를 생각해 볼 수 있다." +
                "\n 하지만 뽑아야 하는 카드가 8장일경우 포커가 2쌍 선택되는 경우가 중복 될 수 있다." +
                "\n 따라서 포함 배제의 원리를 이용하여 1개 이상의 포커를 뽑는 경우의 수를 도출해야 한다. " +
                "\n 예를들어 13의 카드를 뽑을때 1쌍 이상의 포커를 뽑는 경우의 수는 아래와 같다." +
                "\n ans = COMB[13][1] * COMB[52-4][13-4] - COMB[13][2] * COMB[52-8][13-8] + COMB[13][3] * COMB[52-12][13-12] " +
                "\n k쌍 이상을 뽑는 경우의 수 = 1한쌍뽑는 경우 - 2쌍뽑는 경우 + 3쌍뽑는 경우 - 4쌍뽑는 경우 .... ",
                "문제링크" : "https://www.acmicpc.net/problem/16565", 
                "코드링크" : "https://www.acmicpc.net/source/81943011"
            },
            {
                "분류" : "dijkstra DP",
                "제목": "KCM Trable",
                "문제": "Node 1 에서 N 까지 가는데 주어진 한계비용을 초과하지 않는 한도 내에서 가장 빨리 도착하는 방법을 찾기",
                "해법": "비용 기준으로 2차원 Dijkstra DP 로 구현하는데 시간 초과를 해법하기 위해 몇가지 기술을 적용해야 한다." +
                "\n 1) DEST[k][cost] 값이 업데이트 되면 DEST[k][const + 1] ~ DEST[k][const + Limit] 까지의 값도 같이 업데이트해주어야 한다." +
                "\n 2) K 가 최종 도착지라면 loop 를 빠져나온다. 우선순위가 소요시간 기준이기 때문이다." +
                "\n 3) Edge 를 비용기준으로 정렬해 주어야 한다.",
                "문제링크" : "https://www.acmicpc.net/problem/10217", 
                "코드링크" : "https://www.acmicpc.net/source/81962027"
            },
            {
                "분류" : "DP + Greedy",
                "제목": "커플 만들기",
                "문제": "남자 N명 여자 M 명을 최대한 매칭하였을때 성격차이가 최소화 되도록 매칭 하는 경우를 찾기",
                "해법": "남자,여자를 각각 성격순으로 정렬한다." +
                "\n DP[i][j] 는 i 번째 남자와 j 번째 여자를 매칭하였을 때 최소 성격차로 정의" +
                "\n DP[i][j] = min(DP[i-1][0] .. DP[i-1][j-1]) + diff(N[i] , M[j]) 로 계산하면 된다.",
                "문제링크" : "https://www.acmicpc.net/problem/1727", 
                "코드링크" : "https://www.acmicpc.net/source/82069160"
            },
            {
                "분류" : "누적합,비트마스크",
                "제목": "XOR 합 3",
                "문제": "수열의 모든 부분수열의 XOR 합을 구하기",
                "해법": "S[i] 를 A[0] ... A[i] 까지의 XOR 이라고 정의하면 모든 S[i] 를 미리 계산해 놓는다." +
                "\n 모든 I 를 순회하면서 각비트별로 1 인경우 홀수 Count 감소 후 홀수 짝수 swap" +
                "\n 각 비트별로 0 인경우 짝수 count 를 감소시키면서 홀수 카운트 만큼 결과에 반복 더해준다.",
                "문제링크" : "https://www.acmicpc.net/problem/13710", 
                "코드링크" : "https://www.acmicpc.net/source/82075352",
                "대표이미지" : "bj_13710.png",
            },
            {
                "분류" : "DP",
                "제목": "방법을 출력하지 않는 숫자 맞추기",
                "문제": "N 개의 나사가 쌓여있고 왼쪽으로 돌리면 아래의 모든 나사들이 같이돌아가고 오른쪽으로만 돌리면 현재 나사만 돌아간다." +
                "\n 시작숫자에서 끝숫자 까지 이르는데 나사를 돌리는 최소 횟수를 구해야 함.",
                "문제이미지" : "bj_13392.png",
                "해법": "i 번째 나사기준으로 왼쪽으로 몇번 돌았을때 N번째 까지 모두 맞추는데 얼마나 걸리는지 계산하는 table 을정의한다" +
                "\n DP[i][왼쪽 돌아간 횟수] = min(DP[i+1][i번째를 맞추기 위해 돌려야할 왼쪽회전수] + 회전수를 달성하기 위한 추가 왼쪽 회전수, " +
                "\n DP[i+1][왼쪽 돌아간횟수] + 회전수를 달성하기 위한 추가 오른쪽 회전수)", 
                "문제링크" : "https://www.acmicpc.net/problem/13392", 
                "코드링크" : "https://www.acmicpc.net/source/82233795",
                "대표이미지" : "bj_13392_2.png",
            },
            {
                "분류" : "DP",
                "제목": "숫자 맞추기",
                "문제": "앞의문제 BJ-13392 와 동일하지만 어떤 나사를 어느쪽으로 움직였는지 경로를 출력해 주어야함",
                "해법": "trace table 을 만들어 TRACE[i][j] = pair(next 회전수, 현재나사를 맞추기위한 회전수) 로 정의하여 TRACE[0][0] 부터 추적하면 된다",
                "문제링크" : "https://www.acmicpc.net/problem/2494", 
                "코드링크" : "https://www.acmicpc.net/source/82234443",
            },
            {
                "분류" : "DP",
                "제목": "타일 채우기",
                "문제": "3*N 크기의 벽을 2X1 또는 1X2 타일로 채우는 경우의 수 구하기",
                "해법": "DP[i][000~111] = i 변째 까지 벽돌을 채우는데 제일 오른쪽 벽돌이 부분적으로 채워졌을 때 채울 수 있는 경우의 수로 정의하여 테이블을 채우면 된다." +
                "\n 단 최초 가상의 벽을 만들고 DP[0][7] 만 1로 채운다. 왜냐하면 첫번째 줄은 이전 줄을 침범하여 벽돌을 쌓을 수 없기 때문이다",
                "문제링크" : "https://www.acmicpc.net/problem/2133", 
                "코드링크" : "https://www.acmicpc.net/source/82260641",
                "대표이미지" : "bj_2133.png",
            },
            {
                "분류" : "DP",
                "제목": "동전문제",
                "문제": "특정금액을 채울수 있는 동전의 최소 갯수 구하기",
                "해법": "금액이 최대 10^17 이므로 전체 금액을 DP table 로 채울 수는 없다. 다만 동전에 규칙이 있기 때문에 규칙을 파악하는 것이 핵심." +
                "매 백단위 마다 1, 10,25 짜리 동전으로 가정할 수 있기 때문에 0~99 까지 만들수 있는 최소 동전을 만들고 2자리 단위로 끊어서 더하면 됨.",
                "문제링크" : "https://www.acmicpc.net/problem/1398", 
                "코드링크" : "https://www.acmicpc.net/source/82505436",
                "대표이미지" : "bj_1398.png",
            },
        ];

        // 줄바꿈 문자를 <br> 태그로 변환하는 함수
        function nl2br(str) {
            return str.replace(/\n/g, '<br>');
        }

        // JSON 배열의 각 행을 개별 HTML 테이블로 변환하는 함수
        function jsonToIndividualTables(jsonArray) {
            const container = document.createElement('div');

            jsonArray.forEach((item, index) => {
                const table = document.createElement('table');

                // 테이블 헤더 생성
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = Object.keys(item);
                headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // 테이블 바디 생성
                const tbody = document.createElement('tbody');
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    // 줄바꿈 문자를 <br> 태그로 변환하여 innerHTML에 할당

                    if (header === '문제링크' || header === '코드링크') {
                        const link = document.createElement('a');
                        link.href = `${item[header]}`;
                        if (item[header] == '아직못품')
                            link.textContent = '아직못품';
                        else
                            link.textContent = 'CLICK';
                        link.target = '_blank';
                        td.appendChild(link);
                    } else if(header == "대표이미지" || header == "문제이미지") {
                        const img = document.createElement('img');
                        img.src = item[header];
                        td.appendChild(img);
                    }
                    else {
                        td.innerHTML = nl2br(item[header].toString());
                    }
                    row.appendChild(td);
                });
                tbody.appendChild(row);
                table.appendChild(tbody);

                // 짝수 인덱스 테이블에 클래스 추가
                if (index % 2 === 0) {
                    table.classList.add('table-even');
                } else {
                    table.classList.add('table-odd');
                }

                container.appendChild(table);
            });

            return container;
        }

        // 개별 테이블을 페이지에 추가
        const tableContainer = document.getElementById('table-container');
        const tables = jsonToIndividualTables(jsonData);
        tableContainer.appendChild(tables);
    </script>

</body>
</html>
